<#@ template language="C#" hostspecific="True" #>
<#@ output extension=".cs" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data"#>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Data.Common" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Data.SqlClient" #>
<#@ import namespace="System.IO"#>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating"#>
<#+

	string ConnectionString = "";
	string Namespace = "";
	string RepoName = "";
	string ClassPrefix = "";
	string ClassSuffix = "";
	string SchemaName = null;
	string[] ExcludePrefix = new string[] {};
	string[] ClassReplaces = new string[] {};
	Dictionary<string, string> EnumLists = new Dictionary<string, string> {};
	List<Tuple<string,string,bool,string,string,string>> ReferenceLists = new List<Tuple<string,string,bool,string,string,string>>{};

	public class Table
    {
	    public List<Column> Columns { get; set; }
        public string Name { get; set; }
		public string Schema;
		public bool IsView;
        public string Primkey { get; set; }
		public string CleanName;
        public string ClassName { get;set; }
		public string SequenceName;
		public bool Ignore;

		public Column PK
		{
			get
				{
					return this.Columns.SingleOrDefault(x=>x.IsPK);
				}
		}
    }

	public class Column
    {
        public string Name { get; set; }
		public string PropertyName;
        public string PropertyType { get; set; }
		public string Remark;
		public bool IsPK;
		public bool IsNullable;
		public bool IsAutoIncrement;
		public bool Ignore;
    }

	public class Tables : List<Table>
	{

		public Tables()
		{
		}
	
		public Table GetTable(string tableName)
		{
			return this.Single(x=>string.Compare(x.Name, tableName, true)==0);
		}

		public Table this[string tableName]
		{
			get
			{
				return GetTable(tableName);
			}
		}

	}

	// Manager class records the various blocks so it can split them up
class Manager {
    private class Block {
        public String Name;
        public int Start, Length;
        public bool IncludeInDefault;
    }
    private Block currentBlock;
    private List<Block> files = new List<Block>();
    private Block footer = new Block();
    private Block header = new Block();
    private ITextTemplatingEngineHost host;
    private StringBuilder template;
    protected List<String> generatedFileNames = new List<String>();
 
    public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template) {
        return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
    }
 
    public void StartNewFile(String name) {
        if (name == null)
            throw new ArgumentNullException("name");
        CurrentBlock = new Block { Name = name };
    }
 
    public void StartFooter(bool includeInDefault = true) {
        CurrentBlock = footer;
        footer.IncludeInDefault = includeInDefault;
    }
 
    public void StartHeader(bool includeInDefault = true) {
        CurrentBlock = header;
        header.IncludeInDefault = includeInDefault;
    }
 
    public void EndBlock() {
        if (CurrentBlock == null)
            return;
        CurrentBlock.Length = template.Length - CurrentBlock.Start;
        if (CurrentBlock != header && CurrentBlock != footer)
            files.Add(CurrentBlock);
        currentBlock = null;
    }
 
    public virtual void Process(bool split, bool sync = true) {
        if (split) {
            EndBlock();
            String headerText = template.ToString(header.Start, header.Length);
            String footerText = template.ToString(footer.Start, footer.Length);
            String outputPath = Path.GetDirectoryName(host.TemplateFile);
            files.Reverse();
            if (!footer.IncludeInDefault)
                template.Remove(footer.Start, footer.Length);
            foreach(Block block in files) {
                String fileName = Path.Combine(outputPath, block.Name);
                String content = headerText + template.ToString(block.Start, block.Length) + footerText;
                generatedFileNames.Add(fileName);
                CreateFile(fileName, content);
                template.Remove(block.Start, block.Length);
            }
            if (!header.IncludeInDefault)
                template.Remove(header.Start, header.Length);
        }
    }
 
    protected virtual void CreateFile(String fileName, String content) {
        if (IsFileContentDifferent(fileName, content))
            File.WriteAllText(fileName, content);
    }
 
    public virtual String GetCustomToolNamespace(String fileName) {
        return null;
    }
 
    public virtual String DefaultProjectNamespace {
        get { return null; }
    }
 
    protected bool IsFileContentDifferent(String fileName, String newContent) {
        return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
    }
 
    private Manager(ITextTemplatingEngineHost host, StringBuilder template) {
        this.host = host;
        this.template = template;
    }
 
    private Block CurrentBlock {
        get { return currentBlock; }
        set {
            if (CurrentBlock != null)
                EndBlock();
            if (value != null)
                value.Start = template.Length;
            currentBlock = value;
        }
    }
 
    private class VSManager: Manager {

        private EnvDTE.ProjectItem templateProjectItem;
        private EnvDTE.DTE dte;
        private Action<String> checkOutAction;
        private Action<IEnumerable<String>> projectSyncAction;
 
        public override String DefaultProjectNamespace {
            get {
                return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
            }
        }
 
        public override String GetCustomToolNamespace(string fileName) {
            return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
        }
 
        public override void Process(bool split, bool sync) {
            if (templateProjectItem.ProjectItems == null)
                return;
            base.Process(split, sync);
            if (sync)
                projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
        }
 
        protected override void CreateFile(String fileName, String content) {
            if (IsFileContentDifferent(fileName, content)) {
                CheckoutFileIfRequired(fileName);
                File.WriteAllText(fileName, content);
            }
        }
 
        internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
            : base(host, template) {
            var hostServiceProvider = (IServiceProvider) host;
            if (hostServiceProvider == null)
                throw new ArgumentNullException("Could not obtain IServiceProvider");
            dte = (EnvDTE.DTE) hostServiceProvider.GetService(typeof(EnvDTE.DTE));
            if (dte == null)
                throw new ArgumentNullException("Could not obtain DTE from host");
            templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
            checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
            projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
        }
 
        private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames) {
            var keepFileNameSet = new HashSet<String>(keepFileNames);
            var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
            var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
            foreach(EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                projectFiles.Add(projectItem.get_FileNames(0), projectItem);
 
            // Remove unused items from the project
            foreach(var pair in projectFiles)
                if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                    pair.Value.Delete();
 
            // Add missing files to the project
            foreach(String fileName in keepFileNameSet)
                if (!projectFiles.ContainsKey(fileName))
                    templateProjectItem.ProjectItems.AddFromFile(fileName);
        }
 
        private void CheckoutFileIfRequired(String fileName) {
            var sc = dte.SourceControl;
            if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
                checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
        }
    }
	}

	Tables LoadTables()
	{
	
		List<String> TableNameList = new List<String>();
        Tables TableList = new Tables();

		SqlConnection con = new SqlConnection(ConnectionString);
        con.Open();

            SqlCommand cmd = new SqlCommand("select name from sysobjects where xtype='u'", con);
            var reader = cmd.ExecuteReader();
            while (reader.Read())
            {
                var tablename = reader.GetValue(0).ToString();
                TableNameList.Add(tablename);
            }

            foreach (var tablename in TableNameList)
            {
                var Table = new Table();
                Table.Name = "dbo." + tablename;
				Table.ClassName = ClassPrefix + tablename + ClassSuffix;

                #region 获取主键
                SqlCommand cmd_prikey = new SqlCommand("EXEC sp_pkeys @table_name='" + tablename + "' ", con);
                var key_result = cmd_prikey.ExecuteReader();
                while (key_result.Read())
                {
                    Table.Primkey = key_result.GetValue(3) != null ? key_result.GetValue(3).ToString() : null;
                }
                #endregion

                #region 获取列名
                SqlCommand cmd_table = new SqlCommand("select COLUMN_NAME,DATA_TYPE,NUMERIC_SCALE,IS_NULLABLE from information_schema.columns where TABLE_NAME='" + tablename + "'", con);
                var table_result = cmd_table.ExecuteReader();
                List<Column> Columns = new List<Column>();

                while (table_result.Read())
                {
                    Column Columindex = new Column();
                    Columindex.Name = table_result.GetValue(0) != null ? table_result.GetValue(0).ToString() : null;
                    if (!String.IsNullOrEmpty(Columindex.Name))
                    {
                        var ColumTypeStr = GetPropertyType(table_result.GetValue(1) != null ? table_result.GetValue(1).ToString() : null, table_result.GetValue(2) != null ? table_result.GetValue(2).ToString() : null);
                        if (table_result.GetValue(3).ToString() == "YES" && ColumTypeStr != "string" && ColumTypeStr != "Guid")
                        {
                            ColumTypeStr = ColumTypeStr + "?";
                        }
                        Columindex.PropertyType = ColumTypeStr;
                        Columns.Add(Columindex);
                    }
                }
                #endregion

                Table.Columns = Columns;
                TableList.Add(Table);
            }
            con.Close();
            con.Dispose();

			return TableList;


	}


	        private string GetPropertyType(string sqlType, string dataScale)
        {
            string sysType = "string";
            sqlType = sqlType.ToLower();
            switch (sqlType)
            {
                case "bigint":
                    sysType = "long";
                    break;
                case "smallint":
                    sysType = "short";
                    break;
                case "int":
                    sysType = "int";
                    break;
                case "uniqueidentifier":
                    sysType = "Guid";
                    break;
                case "smalldatetime":
                case "datetime":
                case "date":
                    sysType = "DateTime";
                    break;
                case "float":
                    sysType = "double";
                    break;
                case "real":
                case "numeric":
                case "smallmoney":
                case "decimal":
                case "money":
                case "number":
                    sysType = "decimal";
                    break;
                case "tinyint":
                    sysType = "byte";
                    break;
                case "bit":
                    sysType = "bool";
                    break;
                case "image":
                case "binary":
                case "varbinary":
                case "timestamp":
                    sysType = "byte[]";
                    break;
            }
            if (sqlType == "number" && dataScale == "0")
                return "long";

            return sysType;
        }

#>